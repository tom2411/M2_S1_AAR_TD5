= Spring
ifndef::masterdoc[]
include::header.adoc[]
endif::masterdoc[]

Containers légers vs containers lourds

== Problématique

[.thumb]
image::archi-complete.png[scaledwidth=75%]

- C’est gentil de faire X couches,
comment on récupère la couche N-1 dans la couche N ? Un bon new ?

- Et mes transactions, c’est qui qui va les faires ?

- Et la gestion des exceptions ?

- Et la gestion de la sécurité, c’est pas moi quand même ?


== Containers

Ces fonctionnalités sont en général fournies par un `container`

2 approches :

* Utiliser une pile complète d'implémentations et utiliser les implémentations fournies
** Approche JEE
* Utiliser une pile minimale et ajouter les éléments supplémentaires nécessaires [par dépendances]
** Approche Spring



== Sources des données

* Vous devez utiliser une DataSource, qui doit vous fournir un pool de connexions

* Cette DataSource peut être configurée via JNDI
   ** Cas « normal » en Java EE
   ** Configuration répandue en production, car les paramètres de connexion à la base sont gérés par les équipes d'exploitation

* Elle peut également être gérée dans l'application
   ** Cas fréquent avec Spring
   ** Permet à l'application d'être une unité simple à déployer
   ** Permet de gérer des cas plus complexes qu'avec JNDI


== pour JPA ?

* Dans tous les cas, utilisation de JPA de manière identique
  ** Avec Java EE
    *** L'implémentation JPA, le cache, etc... sont fournis par le serveur d'applications
    *** Vous aurez nettement moins de configuration, support global par votre éditeur
  ** Avec Spring
    *** Vous pourrez tout modifier et tout paramétrer
    *** Vous serez portable d'un serveur à l'autre
    *** Vous aurez accès à des APIs non standard, comme Spring Data
    *** Mais vous aurez plus de travail à tout configurer, et vous n'aurez pas le support de votre éditeur

 

== EJB (3.X)
 
[%step]
Les EJB 3 en 5 secondes …

Cf Matthieu Exbrayat
 

== Spring

Une brève histoire de Spring

* Octobre 2002 Rod Johnson publie son livre «Expert One-on-One J2EE Design and Development», dans lequel il propose du code, qui va devenir plus tard le framework Spring
* Mars 2004 Spring 1.0 sort sous licence Apache 2.0
* 2005 Spring devient populaire, en particulier en réaction par rapport aux EJBs 2.x
* 2006 Spring gagne un «Jolt Productivity Award», ce qui assoit sa notoriété
* 2007 Sortie de Spring 2.5, avec support des annotations
* 2009 Achat de SpringSource par VMWare (420 M$)
* 2013 Création de Pivotal, une joint venture entre VMWare et EMC Corporation


== Qu’est ce que Spring ?

* Un framework Java
* Un conteneur IoC
* Un ensemble de projets
* Une communauté et une société
* Open Source : licence Apache 2.0


== Qu’est-ce que Spring ?

* Spring n’est pas un serveur d’applications
   ** Il peut fonctionner sans serveur d’applications (application «stand alone», par exemple un batch)
   ** Il peut fonctionner à l’intérieur d’un serveur d’applications
* Il peut alors utiliser les fonctionnalités du serveur, pour en simplifier ou en abstraire le fonctionnement

ifdef::backend-revealjs[== !]

* Il peut également remplacer certaines fonctionnalités du serveur, si on juge que Spring propose une meilleure alternative
* Généralement Spring est utilisé conjointement à un serveur d’applications léger : Tomcat ou Jetty
   ** Peu d’intérêt à utiliser Spring dans un serveur Java EE «complet»
   ** Mais Spring fonctionne également parfaitement avec Weblogic, WebSphere, Glassfish, etc

 
== Spring : Architecture complète et modulaire

[.thumb]
image::spring-stack.png[scaledwidth=75%]

== Spring : organisation

L’organisation de Spring est modulaire. Pourvu d’un module de base « Spring core », six modules
d’inégales importances apparaissent (en gras les modules majeurs):

* Spring Core : module de gestion des dépendances entre beans (implémente L’injection de
dépendance)

* Spring AOP : réservé à des développements très spécifiques

* Spring ORM : Classes utilitaires permettant une intégration intéressante des différentes
framework de mapping O/R, notamment avec Hibernate

ifdef::backend-revealjs[== !]

* Spring DAO : Classes utilitaires facilitant à l’extrême le développement d’une couche
d’accès aux données en jdbc pur.

* Spring Context : permet de masquer une grande partie de la technologie nécessaire pour se
connecter à des ejb, à JNDI, à JMS,… Mais aussi l’internationalisation de nos applications

* Spring Web : comment utiliser Spring depuis une application web

* Spring MVC : Implémenter une application web en respectant le design pattern MVC
(concurrent de struts)



== Spring : un principe fondateur

* IoC => Inversion of Control
   ** Le «principe d’Hollywood» : Ne nous appelez pas, nous vous rappellerons
   ** Permet d’avoir des composants «faiblement couplés»
* Améliore la qualité du code
* Facilite les tests !!
* La principale forme d’IoC : «l’injection de dépendances» (ou DI)

 

== Injection de Dépendances - DI

* A la base, il s’agit simplement d’injecter un objet dans un autre
[source,java]
public class TodosServiceImpl {
    private UserService userService;
}
 
Comment initialiser `userService` ?


== La mauvaise méthode

* La méthode interdite : le NEW, c’est mal
[source,java]
public class TodosServiceImpl {
    private MonSuperUserService userService =
        new MonSuperUserService(plein de params);
}
 


== Réponse classique : exemple de fabrique

[source,java]
----
public class ServiceImpl {
        private BanqueDao dao; ;

        public ServiceImpl(){
                BanqueDao dao = BanqueFactory.getInstance();

...
}
----

* Réponse Spring : injection de dépendance à l’exécution

* [Réponse JEE : injection à la compilation @Inject]

       
 

== Principe de l’IOC

* Un objet de type A dépend d’un objet type B
   ** Exemple : A possède un attribut de type B
* Pour construire un A j’ai besoin d’un B

== IOC : casser cette dépendance ?

* Une interface I : le type A référence I, B implémente I
* Comment instancier avec un B la référence I dans A ?
   ** En construisant A( I )
   ** En appelant un setter après la construction de A

 
== 1ère méthode : go to the setter

* 1ère méthode, «classique» : l’injection par setter
    ** Utilise la convention Java Bean
[source,java]
----
public class TodosServiceImpl {

        private UserService userService;

        public void setUserService(UserService userService) {
                this.userService = userService;
        }
}
----

== 2ème méthode : utiliser le constructeur

* méthode relativement populaire : utiliser le constructeur de l’objet

[source,java]
----
public class TodosServiceImpl {

        private UserService userService;

        public TodosServiceImpl(UserService userService) {
                this.userService = userService;
        }
}
----

== 3ème méthode : injecte dans le champ

* 3ème méthode : Spring injecte directement dans le champ
   ** Méthode «magique» : en fait les champs «private» en Java peuvent être modifiés (si vous venez d’avoir un cours sur Java, on vous a menti)
   ** De plus en plus populaire car la méthode la plus simple
[source,java]
----
public class TodosServiceImpl {

        private UserService userService;

}
----

== Les 3 méthodes ?

* Injection par setter
    ** Respecte la convention JavaBeans (sans grand intérêt)
    ** Héritage automatique
    ** Plus clair que par constructeur
    ** Permet d’avoir des dépendances optionnelles

ifdef::backend-revealjs[== !]

* Injection par constructeur
    ** Permet d’avoir des objets immutables
    ** Oblige à avoir toutes les dépendances correctement définies
    ** Plus concise que par setter

ifdef::backend-revealjs[== !]
* Injection par champ
    ** Mêmes qualités que par constructeur
    ** Encore plus concise
    ** Mais gênant pour les tests unitaires

 
== Conseils

* Vous pouvez mélanger les 3 types d’injection
   ** Utilisez le plus simple en fonction de votre existant
* L’injection par champ est la plus efficace pour le développement
   ** Utilisez l’injection par setter pour les dépendances optionnelles
* Le plus important est d’être homogène
   ** Si vous injectez votre data source de 3 manières différentes, personne ne va rien y comprendre !
   ** Il est important de mettre en place des règles à ce sujet dès le début du projet

 
== ApplicationContext

* Un Application Context (une des implémentations de l’interface org.springframework.context.ApplicationContext) représente le conteneur Spring : il est chargé de démarrer les beans, de les injecter, de les gérer, de les détruire
* Il en existe de plusieurs sortes : WebApplicationContext pour les applications Web par exemple
* Le rôle de cette classe est de prendre vos objets et votre configuration, et de faire fonctionner l’ensemble

 

== Problèmes à résoudre

* Problèmes Application exemple en TP :
   ** « connections » entre EntityManager/DAO/Façade : injection de l’entityManager dans la DAO, puis de la DAO dans la façade
   ** Gestion des transactions !!!
   ** Gestion des exceptions
   ** Gestion de la sécurité


== Spring : injection de dépendances

* Injection du DAO dans la couche Service :
[source,java]
----
public class ServiceBanque implements Service {
        // lien vers la couche [dao]
        private BanqueDao banque; // pas d’init !!!

        public void setBanque(BanqueDao banque) {
                this.banque = banque;
        }
----
* Dans spring-config :
[source,xml]
<bean id="banqueDao" class="dao.BanqueDaoSpring" />
<bean id="service" class="service.ServiceBanque">
    <property name="banque" ref="banqueDao" />
</bean>

 

== Spring : configuration XML

* Utilise les «namespaces» XML
** Spring fournit une dizaine de namespaces spécialisés : beans, transactions, sécurité, etc...
    ** L’import de ces namespaces permet de considérablement simplifier cette configuration
       *** Propose l’auto-complétion et fournit la documentation
       *** Fonctionne avec tout éditeur XML
       *** Crée automatiquement des ensembles de Beans Spring
* Un Bean a un ID (unique) et une classe (son implémentation)
* Les Beans sont injectés
    ** Par Setter avec <property name="" ref=""/>
    ** Par constructeur avec <constructor-arg ref=""/>

 

== Spring : configuration XML

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi= "http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation= "http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.1.xsd" >

<!-- injection par setter -->
<bean id="todoService" class="example.TodoServiceImpl" >
        <property name="userService" ref="userService" />
</bean>

<!-- injection par constructeur -->
<bean id="userService" class="example.UserServiceImpl" >
        <constructor-arg ref="userRepository" />
</bean>
</beans>
----

== Spring : injection de dépendances

* Possibilité d’injecter les facades (en mock) dans le business delegate
[source,xml]
----
<bean id="myProductServices" class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean">
    <property name="jndiName">
        <value>myProductServices</value>
    </property>

    <property name="businessInterface">
        <value>IProductServices</value>
    </property>
</bean>

<bean id="myController" class="myController">
    <property name="myProductServices">
        <ref bean="myProductServices"/>
    </property>
</bean>
----
 

== Spring : par annotations
[source,java]
----
@Component
public class TodosServiceImpl implements TodosService {

    @Inject
    private UserService userService;

    public Collection<Todo> findAssignedTodos () {
         User user = userService. getCurrentUser ();
         ...
         return assignedTodos;
    }
}
----

== Spring : par annotations

* Il faut préciser dans le fichier XML que l’on veut utiliser les annotations
[source,xml]
<beans xmlns="...">
<context:component-scan base-package= "example.test" />
</beans>

* Les Beans annotés @Component sont automatiquement créés [Singleton]
* Les Setters, constructeurs et champs annotés avec @Inject sont automatiquement injectés

 

== Spring : recherche des deps

* Le plus évident : par nom
   ** Pour injecter un Bean nommé «userService», Spring recherche le Bean qui a cet ID (ref)
   ** C’était l’exemple de configuration XML

ifdef::backend-revealjs[== !]
* Le plus concis : par type
   ** On ne nomme pas le Bean à injecter : Spring recherche alors son Type
   ** Comprendre type au sens Java : Spring recherche alors quel Bean est de ce type là (même classe, ou bien implémentant cette interface)
   ** Si Spring en trouve un, il l’injecte, et tout se passe bien
       *** S’il n’en trouve pas on a alors une Exception, et Spring ne peut pas se lancer
       *** S’il en trouve plusieurs, on a également une Exception
   ** C’était l’exemple de configuration par annotations

 

== Spring : 3 modes de configuration

* XML : méthode «classique», très souple et très puissante
   ** Essentielle à connaître
   ** Convient très bien à la configuration dite «d’infrastructure»
* Annotations : depuis Spring 2.5
   ** Plus « rapide » à utiliser
   ** Plus simple : ne convient qu’à de la configuration «métier»

ifdef::backend-revealjs[== !]
* Java : depuis Spring 3.0
   ** Permet de coder en Java quelque chose de similaire à la configuration XML
   ** Plus puissant (c’est du code, on peut faire ce qu’on veut)
   ** Moins simple à modifier, en particulier pour de la configuration «d’ infrastructure»
   ** Moins répandu

 
== Spring : nommage

* Tout Bean est référencé dans le conteneur Spring avec un nom unique
   ** Si deux Beans ont le même nom, vous aurez une Exception au démarrage

ifdef::backend-revealjs[== !]
* Ce nom est libre, mais par convention on utilise généralement le nom de la classe (ou de l’interface implémentée), en CamelCase, en commençant par une minuscule
   ** «dataSource», «monServiceMetier», «entityManager»
   ** L’homogénéité du nommage dans l’application est important
   ** Bien nommer les Beans aide pour la Programmation Orientée Aspect.
      *** Par exemple, pour sélectionner tous les Beans dont le nom finit par «Metier».
   ** A l’origine, en configuration XML, ce nom était l’ID XML du Bean
      *** Garantit l’unicité dans un fichier XML (norme XML)
      *** Mais cela interdisait certains caractères («/») ainsi que de donner deux noms différents au même Bean (il fallait utiliser un alias)

 
== Spring : nommage avec annotations

* Configuration par défaut : «todosServiceImpl»
[source,java]
@Component
public class TodosServiceImpl {
    private UserService userService;
}

* En nommant explicitement le Bean
[source,java]
@Component ("todosService")
public class TodosServiceImpl {
    private UserService userService;
}
 

== Spring : annotations spécifiques

* Pour les couches standards, remplace @Component

* Pour la DAO : `@Repository("clientDao")`

* Pour la couche de service : `@Service("helloBanque")`

* Dans `org.springframework.stereotype.*`

 

== Scope des beans Spring

* singleton : Scopes a single bean definition to a single object instance
per Spring IoC container.

* prototype : Scopes a single bean definition to any number of object instances.

* request : Scopes a single bean definition to the lifecycle of a single HTTP request;
that is each and every HTTP request will have its own instance of a bean created off the back
of a single bean definition. [Only valid web-aware Spring ApplicationContext]

* session : Scopes a single bean definition to the lifecycle of a HTTP Session.
[Only valid web-aware Spring ApplicationContext]

* global session Scopes a single bean definition to the lifecycle of a global HTTP Session.
[Only valid web-aware Spring ApplicationContext]
 

== Les Scopes en VF

* Par défaut, les Beans Spring sont dits être des «singletons»
  ** Ils ne sont instanciés qu’une seule fois par contexte Spring
  ** Ils ne sont pas de «vrais» singletons : on peut lancer deux fois la même classe (deux Beans ayant la même implémentation)
* Les Beans sont instanciés et configurés au démarrage du contexte Spring
  ** Permet de valider que la configuration est correcte dès le démarrage de l’application
  ** Permet de gagner en performance : on ne crée pas un grand nombre d’instances d’objets pour rien


== Les Scopes en VF…

* Le fait d’avoir des singletons a un impact en environnement multi-threadé
  ** Les variables de classe sont partagées entre les threads
  ** Les beans doivent donc être thread-safe
[source,java]
@Service
@Transactional
public class TodosServiceImpl implements TodosService {
    @Inject
    private UserService userService;
}
 

== Les Scopes en VF…

* Que faire si vous avez besoin de plusieurs instances du même Bean ?
** Exemple très fréquent : il contient des données de l’utilisateur

* On peut donner un «scope» à un Bean
** singleton, session, flow, request, prototype
** prototype : une nouvelle instance à chaque fois qu’on injecte ce Bean
[source,xml]
<bean id="todoService" class="example.TodoServiceImpl" scope="prototype" >
    <property name="userService" ref="userService" />
</bean>
 

== It’s alive !

* La vie des Beans est gérée par Spring
    ** C’est Spring qui crée les Beans
    ** C’est Spring qui les «enrichit» avec la Programmation Orientée Aspect
    ** C’est Spring qui les injecte
    ** C’est Spring qui les détruit (parfois)

* Ce cycle de vie est défini par Spring
    ** Spring propose également des options de configuration pour agir sur les Beans, au moment de leur création ou de leur destruction

 

== Etape 1 : lecture de la config

* Au démarrage, Spring lit sa configuration
   ** Dans un fichier XML
   ** Dans les annotations
   ** Dans la configuration Java de Spring
* Spring possède alors un modèle mémoire de la configuration qu’on lui a fournie
   ** A partir de ce moment, Spring ne différencie plus d’où provient la configuration
   ** Il est donc impossible d’avoir un comportement différent entre une configuration XML et une configuration par annotation (= en cas de problème, c’est votre configuration qui est mauvaise)


== BeanFactoryPostProcessor

* Spring propose à ce moment un premier point d’extension : le BeanFactoryPostProcessor
  ** Il permet de modifier la configuration des Beans
* Exemple typique : le PropertyPlaceholderConfigurer
  ** Permet de remplacer des variables (de type ${} ) par des valeurs externes à l'application, par exemple en provenance d’un fichier .properties
  ** Très souvent utilisé, le fichier plat pouvant être modifié facilement par des administrateurs ou des scripts


== Exemple

[source,xml]
----
<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer" >
    <property name="locations" value="classpath:com/foo/jdbc.properties" />
</bean>

<bean id="dataSource" destroy-method= "close"
        class="org.apache.commons.dbcp.BasicDataSource" >
    <property name="driverClassName" value="${jdbc.driverClassName}" />
    <property name="url" value="${jdbc.url}" />
    <property name="username" value="${jdbc.username}" />
    <property name="password" value="${jdbc.password}" />
</bean>
----

== Etape 2 : instantiation et injection

* Une fois la configuration traitée par Spring, celui-ci va créer les Beans (scope Singleton) qui ont été définis
    ** Il crée les Beans en utilisant l’API Reflection de Java
    ** Il crée les Beans dans le bon ordre
        *** Il fait normalement l’injection de dépendance après l’instantiation des Beans
        *** Sauf pour l’injection de dépendance par constructeur
        *** Attention aux dépendances cycliques dans ce cas (mais elles sont généralement la preuve d’une mauvaise architecture)

ifdef::backend-revealjs[== !]

* C’est au moment de l’injection que Spring crée des «proxy» sur les objets
   ** Si nécessaire, Spring génère une implémentation «enrichie» des objets
   ** Ajout des transactions, de la sécurité, etc...
       *** C’est ainsi que fonctionne la Programmation Orientée Aspect
* Tant que l’injection de dépendance n’a pas eu lieu, les objets ne sont donc pas prêts à être utilisés

 

== Etape 3 : init des beans

* Une fois tous les Beans créés et injectés par Spring, un nouveau point d’extension est disponible
    ** Il ne faut pas utiliser les constructeurs des objets pour faire des choses complexes, car les Beans ne sont pas encore prêts (l’injection de dépendance n’est pas encore faite)
* On peut alors initialiser les Beans, avec 3 méthodes
   ** Une annotation @PostConstruct
   ** Une configuration XML (attribut «init-method»)
   ** Une interface à implémenter (InitializingBean)

ifdef::backend-revealjs[== !]

* La manière recommandée est d’utiliser l’annotation
* Elle est standardisée (JSR 250) : aucune dépendance sur Spring !
    ** Elle est simple et peu intrusive

 
== Exemple

[source,java]
----
@Service
@Transactional
public class TodosServiceImpl {
   @PostConstruct
   public void init() {
       System. out.println("Bonjour de TodosServiceImpl" );
   }
}
----

* Astuce : c’est un bon moyen pour vérifier si vos Beans sont bien démarrés

 

== Etape 4 : Run

* Une fois les Beans instanciés, injectés et initialisés le conteneur Spring est prêt à l’emploi
  ** Il devient accessible (on peut lui demander un Bean via l’API)
  ** L’application est prête et est démarrée
* C’est dans cette phase que votre application se trouve 99% du temps
  ** Sauf si elle crashe souvent :-)

 

== Etape 5 : Destruction (option)

[source,java]
----
@Service
@Transactional
public class TodosServiceImpl {
   @PreDestroy
   public void destroy() {
        System. out.println("Au revoir de TodosServiceImpl" );
   }
}
----

WARNING: pour un Prototype cette méthode ne sera pas appelée («fire and forget»)

 

== Cas particulier

* Que faire si vos beans sont lents au démarrage ?
   ** Un exemple possible : l’initialisation d’un cache
* On ne va pas vouloir suivre le cycle de vie classique : on veut avoir des Beans uniquement instanciés à la demande : c’est le «lazy loading»

ifdef::backend-revealjs[== !]
* C’est généralement une fausse bonne idée :
   ** Le premier utilisateur à utiliser cet objet va alors subir le chargement
   ** Il y a toujours un risque de mauvaise configuration : mieux vaut être sûr du bon lancement de ses Beans au démarrage de l’application
   ** Une solution : avoir une configuration d’infrastructure différente suivant votre environnement, et ne faire le lazy loading qu’en développement
[source,java]
<bean id="todoService" class="example.TodoServiceImpl" lazy-init="true" >
        <property name="userService" ref="userService" />
</bean>
 

== Démarrage de Spring

* Pour démarrer Spring, il faut créer une instance de l’interface ApplicationContext
   ** Plusieurs implémentations existent
   ** Elles sont spécialisées pour certains environnements : application Web, test unitaire, etc...
   ** Elles sont toutes sur le même principe : il faut charger la configuration Spring (habituellement, charger le fichier de configuration XML)

ifdef::backend-revealjs[== !]

* La manière la plus simple :
[source,java]
ApplicationContext ctx =
    new ClassPathXmlApplicationContext("application-context.xml");
 

== Astuces config

* Pour lire le fichier dans le système de fichier :
[source,java]
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("/home/application/config.xml");

* Pour lire plusieurs fichiers (varargs) :
[source,java]
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf-1.xml" ,"conf-2.xml");

* Pour lire tous les fichiers d’un répertoire (pattern Ant) :
[source,java]
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("/home/application/*.xml");
 

== Démarrage Web

* Spring est lancé via un listener dans le fichier web.xml
[source,xml]
----
<context-param>
<param-name>contextConfigLocation</param-name>
<param-value>classpath:META-INF/spring/application-context.xml</param-value>
</context-param>

<listener>
<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
----

CAUTION: cette configuration lance uniquement Spring IoC, sans Spring MVC

 

== Arrêt

* L’application peut parfaitement être arrêtée «normalement» ou crasher...
* Si vous voulez explicitement arrêter Spring :
[source,java]
applicationContext.close();

* Les Beans sont informés qu’ils doivent s’arrêter (@PreDestroy est appelé)
* Les Beans sont détruits
* Le context Spring n’est alors plus utilisable

 

== Spring injection

* Des types simples (eg String, int, …)

* Des collections :
[source,xml]
<property name="emails">
<map>
<entry key="formation" value="formation@ippon.fr" />
<entry key="contact" value="contact@ippon.fr" />
<entry key="recrutement" value="recrutement@ippon.fr" />
</map>
</property>

* Des beans dans d’autres beans

* …

 

== Spring injection : innerBean

* Exemple avec Hibernate :
[source,xml]
----
<bean id="entityManagerFactory"
  class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="jpaVendorAdapter">
    <bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter">
        <property name="database" value="${jpavendoradapter.database}"/>
        <property name="databasePlatform"
          value="${jpavendoradapter.databaseplatform}"/>
        <property name="showSql" value="${jpavendoradapter.showsql}"/>
        <property name="generateDdl"
          value="${jpavendoradapter.generateddl}"/>
        </bean>
        </property>
        <property name="persistenceXmlLocation"
          value="classpath:META-INF/persistence.xml"/>
</bean>
----

== Spring : Exemple complet

Architecture générale de l’application Banque

 

== Spring : exemple

    * 1 : config accès DataSource – persistance.xml 
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="1.0"
    xmlns="http://java.sun.com/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd">

<persistence-unit name="jpa" transaction-type="RESOURCE_LOCAL" >
</persistence-unit>

</persistence>
----
 

== Spring : exemple

* 2 : config accès DataSource – spring-config.xml
[source,xml]
----
<!-- la source de donnéees DBCP -->
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
        destroy-method="close">
    <property name="driverClassName" value="com.mysql.jdbc.Driver" />
    <property name="url" value="jdbc:mysql://localhost:3306/banque" />
    <property name="username" value="root" />
    <property name="password" value="root" />
</bean>
----
 

== Spring : exemple

* 3 : injection dans la DAO : spring-config.xml
[source,xml]
----
<bean id="entityManagerFactory"
  class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
    <property name="dataSource" ref="dataSource" />
    <property name="jpaVendorAdapter">
<bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter">
    <property name="databasePlatform" value="org.hibernate.dialect.MySQLDialect" />
    <property name="generateDdl" value="true" />
</bean>
</property>
</bean>
----
 

== Spring : exemple

* 3 : injection dans la DAO : Banque1.java
[source,java]
----
package dao;

@Transactional
public class Banque1 implements IBanque {
   @PersistenceContext
   private EntityManager em;

   @Transactional(readOnly = true)
   public Collection<Client> getAllClients() {
   ...
----
 

== Spring : exemple

* 4 : injection dans Service : spring-config.xml
[source,xml]
----
<!– définition d’un bean [singleton] -->
<bean id="banqueDao" class="dao.Banque1" />

<!– définition d’un bean [singleton] et injection -->
<bean id="service" class="service.Service1">
        <property name="banque" ref="banqueDao" />
</bean>
----
 

== Spring : exemple

* 4 : injection dans Service : Service1.java
[source,java]
----
package service;

@Service
@Transactional
public class Service1 implements IService {
    // couche [dao] : injection automatique par Spring
    private IBanque banque;

    public void setBanque(IBanque banque) {
         this.banque = banque;
    }
----

== Spring : exemple

* 5 : Gestion des transactions : spring-config.xml
[source,xml]
----
<!-- le gestionnaire de transactions -->
<tx:annotation-driven transaction-manager="txManager" />

<bean id="txManager" class="org.springframework.orm.jpa.JpaTransactionManager">
    <property name="entityManagerFactory"
       ref="entityManagerFactory" />
</bean>
----
 

== Spring : exemple

* La même en FULL annotations

 

== Une configuration typique

* Des fichiers «d’infrastructure»
   ** Plusieurs fichiers, découpés en fonction de leur périmètre fonctionnel
   ** Exemple : un fichier pour configurer la sécurité, un fichier pour configurer la base de données
ifdef::backend-revealjs[== !]
* Des annotations dans les Beans de la couche «métier»
   ** Les développeurs gagnent ainsi en temps de développement
   ** Facilite le refactoring
   ** Recommandation : avoir un IDE qui «comprend» cette configuration (IntelliJ)

 
== Une configuration typique

* Généralement, ces variables injectées sont des paramètres, qui dépendent de l’environnement
   ** Elles se trouvent dans la configuration «d’infrastructure»
   ** Par exemple : l’URL, le login et le mot de passe de la base de données
* Il est plus propre de les externaliser dans un fichier de properties
[source,xml]
----
<context:property-placeholder
    location="classpath*:META-INF/infrastructure/database.properties"/>
<bean id="dataSource"
        class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="user" value="${dataSource.username}"/>
        <property name="password" value="${dataSource.password}"/>
        ...
</bean>
----

== Bonnes pratiques

* La configuration métier est réalisée à l’aide d’annotations
   ** Elle ne change pas, quel que soit l’environnement
   ** Elle est ainsi plus rapide à réaliser pour les développeurs
   ** On utilise l’auto-wiring par type : on ne nomme même pas les Beans

 

== Bonnes pratiques

* La configuration d’infrastructure est stockée dans plusieurs fichiers XML :
   ** Tous sont dans le même répertoire : classpath:META-INF/spring/*.xml
   ** Ces fichiers sont spécialisés : applicationContext-database.xml, applicationContext-security.xml, etc...
   ** Ces fichiers sont paramétrables via des fichiers de properties (utilisation du PropertyPlaceholderConfigurer)
   ** Il est également possible d’avoir des fichiers de configuration spécifiques par environnement, si les fichiers de properties ne sont pas suffisants

 

== Spring : les transactions

* Spring propose une couche d’abstraction
   ** Gère les transactions JDBC, Hibernate, JTA etc... de manière homogène
   ** Permet de simplement configurer ses transactions : utilisation d’annotations ou d’XML, sans utilisation obligatoire de code
* Cela permet d’avoir une meilleure architecture
   ** Les transactions sont déclarées dans la couche métier (service), et non dans la couche d’accès aux données (repository / DAO)
   ** Les transactions ne dépendent pas d’une technologie particulière d’accès aux données (JDBC)

 

== Les transactions version simple

* Configurer un gestionnaire de transaction
[source,xml]
<bean id="transactionManager"
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager" >
    <property name="dataSource" ref="dataSource" />
</bean>

* Dire à Spring que l’on veut utiliser les annotations
[source,xml]
<tx:annotation-driven/>

* Utiliser les annotations
[source,java]
@Transactional
public void uneMethodeMetier() {



== Transactions

* Le gestionnaire de transaction est une classe fournie par Spring
   ** Il fait partie de l’infrastructure
   ** Il est spécifique à la technologie utilisée
   ** Hors JTA, il a besoin d’une Data Source pour être configuré
   ** Par convention, il possède l’id «transactionManager»

* Si vous êtes dans un serveur d’applications (Websphere, JBoss...),
Spring peut retrouver automatiquement le gestionnaire de transactions de ce serveur
(utilisant l’API JTA) :
[source,java]
<tx:jta-transaction-manager/>
 

== @Transactional

* L’annotation @Transactional peut être mise sur une classe (toutes les méthodes publiques sont transactionnelles) ou sur une méthode
* Cette annotation peut avoir un certain nombre de paramètres : Isolation, Propagation, Timeout, readOnly…
[source,java]
@Service
@Transactional
public class TodoListsServiceImpl implements TodoListsService {
   @Transactional (readOnly = true)
   public TodoList findTodoList(String listId) {
     // Code métier, utilisant Hibernate par exemple
   }
}
 

== Transaction read-only

* On peut marquer une transaction comme étant «read-only»
    ** On indique qu’elle ne va pas modifier de données en base
    ** En lecture, il est toujours important d’utiliser des transactions, ne serait-ce que pour les performances
ifdef::backend-revealjs[== !]
* Cet attribut est important
    ** Hibernate va le comprendre, il ne va alors plus vérifier s’il doit impacter des modifications sur les objets en base : meilleures performances
    ** Certains drivers JDBC vont le comprendre (Oracle ne vous autorisera plus qu’à faire des «SELECT») : meilleure qualité


== Transactions

* L’utilisation des transactions est essentielle, elle vous garantie la qualité des données
et de bonnes performances
* La configuration des transactions avec Spring est très simple
   ** Utilisation des annotations
   ** Une configuration avancée reste un simple paramétrage
   ** En termes d’architecture, cela permet de gérer les transactions au niveau de la couche métier
    (service), et plus dans les couches basses (repository/DAO)

 

== Transactions

* Exemple de code « propre » pour la couche de service :
[source,java]
----
@Transactional(readOnly = true)
public Collection<Client> getAllClients() {
   return clientDao.findAll();
}

@Transactional(rollbackFor=ClientNotFound.class)
public void updateClient(Client client) throws ClientNotFound {
   Client c = clientDao.findOne(client.getId());
   if (c=null) throw new ClientNotFound();
   c.setAdresse(client.getAdresse());
   c.setNom(client.getNom());
   c.setPrenom(client.getPrenom());
}
----
 

== Profils

* Les profils sont une nouveauté Spring 3.1
  ** Ils permettent de simplifier le découpage en fonction de l’environnement
  ** Ils fonctionnent en configuration XML et Java (annotation @Profile à placer sur le Bean)
  ** Ils simplifient encore plus la configuration d’infrastructure
[source,xml]
<beans profile="production">
  <jee:jndi-lookup id="dataSource"
  jndi-name="java:comp/env/jdbc/datasource"/>
</beans>


== Profils

* Pour choisir un profil au démarrage
   ** Utiliser une variable d’environnement :
         `-Dspring.profiles.active=production`

   ** Le configurer au démarrage via l’API :
[source,xml]
GenericXmlApplicationContext context =
    new GenericXmlApplicationContext();
context.getEnvironment ().setActiveProfiles ("prod");
context.load("classpath:META-INF/spring/applicationContext-*.xml" );
context.refresh();


== Spring AOP

=== Intro à l'AOP

* AOP : Aspect Oriented Programming, ou Programmation
Orientée Aspect en Français
* L’un des deux concepts principaux de Spring (avec l’
Inversion de Contrôle)
* Permet de rajouter des comportements à des classes ou des
méthodes existantes
** Ajouter de la sécurité
** Ajouter la gestion des transactions
** Ajouter du monitoring
* Il s’agit de problématiques transverses
** Elles sont généralement techniques (infrastructure)
** Elles sont plus rarement métier

=== Spring AOP ou AspectJ

* Spring AOP utilise un mécanisme de proxy
** Ne fonctionne que sur des Beans Spring, et son utilisation est très simple
** Est largement suffisant pour des besoins "normaux", ce qui fait que la très
grande majorité des utilisateurs de Spring utilise Spring AOP

ifdef::backend-revealjs[== !]
* AspectJ est une technologie nettement plus complète et complexe
** Repose sur une modification du bytecode des classes Java
** Permet de faire des choses nettement plus compliquées : injecter des Beans
Spring dans des classes standards, par exemple
** Est plus performant en production (mais cela a un impact mineur dans la
réalité : à comparer avec un accès base de données)

ifdef::backend-revealjs[== !]
* Spring AOP utilise le même "langage" que AspectJ, ce qui fait que
l'on peut facilement migrer de Spring AOP vers AspectJ
* Nous allons donc nous concentrer sur Spring AOP

=== Fonctionnement de Spring AOP

* Un proxy «enrobe» le Bean Spring
** Il implémente la même interface, et peut ainsi le remplacer

=== Fonctionnement des proxys

* Ce sont normalement des proxys Java
** Technologie standard Java (introduite dans le JDK 1.3)
** Aujourd'hui suffisamment performants (impact mineur)
** Nécessitent l'utilisation d'une interface
** L'utilisation d'interfaces est recommandée de toute manière (pour les
tests et la souplesse de l'application)

ifdef::backend-revealjs[=== !]

* Si vos classes n'implémentent pas d'interface
** Spring AOP va utiliser CGLIB pour générer le proxy
** CGLIB est une librairie Open Source qui permet de générer des
classes à la volée
** Complique de débuggage et les stack traces
** Aujourd'hui cette technologie est fiable, mais les proxys Java restent
à privilégier

=== Exemple : les transactions

Les transactions sont l’un des Aspects techniques fournis en
standard par Spring

[source,java]
@Service
@Transactional
public class TodosServiceImpl implements TodosService {
    @PersistenceContext
    private EntityManager em;
    @Transactional (readOnly = true)
        public Todo findTodo( final String todoId) {
        return em.find(Todo.class, todoId);
    }
}

=== Plusieurs aspects sur le même bean ?

* Exemple : une méthode est transactionnelle et sécurisée
* Spring ne génère qu'un seul proxy
* Spring va enchaîner ces Aspects
* L'ordre de ces Aspects peut être
paramétré avec l'interface
org.springframework.core.Ordered
ou l’annotation @Order


=== Concepts de l'AOP

* Join point : l'endroit où l'on veut qu’un aspect s'applique.
Avec Spring AOP, il s’agit toujours d’une méthode (du fait de
l'utilisation de proxy)
* Pointcut : une expression, utilisant la syntaxe AspectJ, qui
permet de sélectionner plusieurs Join points. Par exemple,
«toutes les méthodes qui se nomment find()».
* Advice : le code que l'on veut rajouter. On peut ajouter ce
code avant, après, autour de la méthode...
* Aspect : Pointcut + Advice

=== Types d'advices

* Il est possible de définir 5 types d’advices
** Before advice : s’exécute avant le Join point. S’il lance une
Exception, le Join point ne sera pas appelé
** After returning advice : s’exécute après le Join point, si celui-ci s’
est bien exécuté (s’il n’y a pas eu d'Exception)
ifdef::backend-revealjs[== !]
** After throwing advice : s’exécute si une Exception a été lancée
pendant l’exécution du Join point
** After advice : s’exécute après le Join point, qu’il y ait eu une
Exception ou non
** Around advice : s’exécute autour du Join point. C’est l’advice le plus
puissant.

=== Configuration des aspects

* Plusieurs configurations sont possibles
** En XML
** En utilisant des annotations, dite méthode «@AspectJ»
* La méthode @AspectJ est à privilégier
** Plus simple à utiliser
** Permet d’avoir des Pointcut et les Advice au même endroit
* Pour pouvoir utiliser la méthode @AspectJ, ajouter dans
votre configuration Spring : `<aop:aspectj-autoproxy/>`

=== Définition d'un aspect

* Un Aspect est également un Bean Spring
** Mais il ne peut pas y avoir d’Aspect sur un autre Aspect
** On peut séparer le Pointcut de l’Advice, mais c’est plus lisible de tout
mettre dans le même fichier

[source,java]
@Aspect
@Component
public class Monitor {
    @Before("execution(* find(*))" )
    public void monitorFinders() {
        System. out.println("A Finder is fired!" );
    }
}

=== Le langage AspectJ

* La complexité vient en particulier de l’utilisation du langage
AspectJ
** Les bases du langage sont simples,
mais il peut vite devenir très complexe
** Il peut être difficile de sélectionner
l’ensemble des méthodes voulues
** Il faut faire attention à ne pas
sélectionner d’autres méthodes
par erreur
** L’outillage, en particulier d’Eclipse/IntelliJ (plug-in AspectJ) permet de
considérablement simplifier cette tâche

// TODO : suite

=== Utilisation concrète des Aspects

* Spring fournit de nombreux Aspects techniques
** Sécurité
** Transaction
** Gestion des Exceptions
* Vous pouvez faire vos propres Aspects
** Logging
** Monitoring
** Fonctionnalité métier particulière

=== Astuce de config (1)

* Les annotations facilitent considérablement
l’écriture des Point Cut
** On matche sur l’annotation et non sur le package
ou le nom de la méthode
** Exemple : l’annotation @Transactionnal plutôt que «toutes les
méthodes qui commencent par tx»
@annotation (org.springframework .transaction .annotation .Transactional )

=== Astuce de config (2)

* Nous avons déjà vu qu’il fallait découper
les fichiers de configuration Spring en
fonction des fonctionnalités
** Vous pouvez avoir une configuration Spring lisant tous les fichiers
suivants : WEB-INF/spring/aop/*.xml
** Il vous suffit ensuite de copier/coller dans ce répertoire la
configuration des Aspects que vous voulez appliquer sur votre projet
** Par exemple : ajouter ou enlever un Aspect monitorant les méthodes
métier
** Il est ainsi possible d’ajouter ou de modifier des fonctionnalités de l’
application, sans modifier son code source

=== Tester unitairement un Aspect

* Les Aspects que nous avons vus sont des Beans Spring
normaux, avec des annotations
** Pas d’interface ou d’héritage particulier
* Ils sont donc testables unitairement comme n’importe quelle
classe Java simple
** Ces tests sont d’autant plus importants qu’un Aspect est censé
renfermer une fonctionnalité particulière que l’on veut appliquer à de
nombreux autres objets

=== Limitations de Spring AOP

* Ces limitations concernent Spring AOP, mais pas AspectJ
** Ne fonctionne qu’avec les Beans Spring
** Ne s’applique qu’aux méthodes publiques
** Ne fonctionne pas à l’intérieur d’un même Bean

ifdef::backend-revealjs[=== !]

* Cela est dû à l’utilisation des Proxys (on «passe» par une
interface Java)
* Le 3 ème point (une méthode d’un Bean qui appelle
directement une autre méthode du même Bean) est l’une
des plus grandes sources de bugs et d’incompréhension sur
les projets Spring

=== Conclusion sur les Aspects

* C’est une technologie largement utilisée sur les projets
Spring
** Fiable
** Très puissante

ifdef::backend-revealjs[=== !]

* Elle permet de rajouter dynamiquement du code à des
méthodes, de manière transverse et non intrusive
* Bien comprendre son fonctionnement est essentiel
** Pour comprendre comment fonctionne Spring
** Pour pouvoir faire soi-même des Aspects si besoin



== Les transactions Spring

=== Introduction aux transactions

*  Les transactions sont typiquement gérées
par une base de données relationnelles
*  Une transaction est normalement ACID
** Atomique
** Cohérente (Consistant)
** Isolée
** Durable

*  En Java, nous pouvons les gérer via des
APIs simples, par exemple en JDBC ou
avec JTA



=== Utilité des transactions

*  Il est primordial de gérer les transactions si on veut avoir des
données de qualité
**  Les transactions permettent de traiter un ensemble d’opérations
comme une seule opération
**  Pas de données incohérentes dans la base

*  Les transactions permettent également d’avoir de meilleures
performances
**  Il vaut mieux faire 10 requêtes dans une transaction que de faire 10
requêtes dans 10 transactions
**  C’est d’ailleurs une des raisons de leur utilisation dans les batchs



=== Exemple d’une transaction

*  3 requêtes : 1 lecture, 2 écritures
*  1 seule transaction
*  Soit les 2 modifications sont appliquées, soit aucune n’est appliquée
[source,sql]
----
SELECT *
FROM account
WHERE balance > 0;

INSERT INTO account
VALUES (1, 15);

UPDATE account
SET balance = 0
WHERE id = 1;
----


=== Les transactions en Java
*  En JDBC
[source,java]
conn = dataSource. getConnection ();
conn.setAutoCommit (false);
// requêtes SQL
conn.commit();

*  Avec JTA (Java Transaction API)
[source,java]
UserTransaction utx = ctx. getUserTransaction ();
// Démarrage de la Transaction
utx.begin();
// Exécution des requêtes
utx.commit();



=== Spring Transactions

*  Spring propose une couche d’abstraction
**  Gère les transactions JDBC, Hibernate, JTA etc... de manière
homogène
**  Permet de simplement configurer ses transactions : utilisation d’
annotations ou d’XML, sans utilisation obligatoire de code

*  Cela permet d’avoir une meilleure architecture
**  Les transactions sont déclarées dans la couche métier (service), et
non dans la couche d’accès aux données (repository / DAO)
**  Les transactions ne dépendent pas d’une technologie particulière d’
accès aux données (JDBC)



=== Utilisation simple avec Spring

*  Configurer un gestionnaire de transaction
[source,xml]
<bean id="transactionManager"
class="org.springframework.jdbc.datasource.DataSourceTransactionManager" >
<property name="dataSource" ref="dataSource" />
</bean>

*  Dire à Spring que l’on veut utiliser les annotations
[source,xml]
<tx:annotation-driven/>

*  Utiliser les annotations
[source,java]
@Transactional
public void uneMethodeMetier() {
// Unité de travail atomique
}


=== Fonctionnement dans Spring

*  Spring fournit un Aspect spécialisé
**  Le Point Cut est sur les méthodes annotées @Transactional
**  L’Advice est de type Around, et ajoute la gestion des transactions
autour des méthodes annotées

*  C’est le fonctionnement que nous avons vu dans le chapitre
sur Spring AOP, avec la génération d’un proxy
**  Ne fonctionne que sur les Beans Spring
**  Ne fonctionne que sur les méthodes publiques
**  Ne fonctionne pas à l’intérieur d’un même Bean



=== Configuration d’un gestionnaire de transaction

*  Le gestionnaire de transaction est une classe fournie par
Spring
** Il fait partie de l’infrastructure
** Il est spécifique à la technologie utilisée
** Hors JTA, il a besoin d’une Data Source pour être configuré
** Par convention, il possède l’id «transactionManager»

*  Si vous êtes dans un serveur d’applications (Websphere,
Weblogic...), Spring peut retrouver automatiquement le
gestionnaire de transactions de ce serveur (utilisant l’API
JTA) :
[source,java]
<tx:jta-transaction-manager/>



=== Utilisation des annotations

*  L’annotation @Transactional peut être mise sur une classe
(toutes les méthodes publiques sont transactionnelles) ou
sur une méthode
*  Cette annotation a un certain nombre de paramètres :
Isolation, Propagation, Timeout, readOnly…
[source,java]
@Service
@Transactional
public class TodoListsServiceImpl implements TodoListsService {
    @Transactional (readOnly = true)
    public TodoList findTodoList(String listId) {
    // Code métier, utilisant Hibernate par exemple
    }
}



=== Variante : utilisation du XML

*  On peut également utiliser une configuration XML
**  On code alors un Point Cut spécifique : par exemple toutes les
méthodes des classes d’un package spécifique
**  On privilégiera la configuration par annotations : elle est plus simple
et plus lisible
[source,xml]
<aop:config>
<aop:pointcut id="serviceBeans"
expression= "execution(public * test.service.*(..))" />
<aop:advisor pointcut-ref= "serviceBeans" advice-ref= "txAdvice" />
</aop:config>
<tx:advice id="txAdvice" >
<tx:attributes>
<tx:method name="find*" read-only= "true"/>
<tx:method name="*"/>
</tx:attributes>
</tx:advice>



=== Le TransactionTemplate

*  Si la configuration par annotations ou XML n’est pas
suffisante, Spring propose une API
**  Elle utilise le système des Templates et des Callbacks que nous
avons déjà vus pour Spring JDBC
[source,java]
transactionTemplate.execute(new TransactionCallbackWithoutResult() {
    protected void doInTransactionWithoutResult(TransactionStatus status) {
        try {
            insertionEnBase();
            miseAJourDeLaBase();
        } catch (ExceptionMetier ex) {
            status. setRollbackOnly ();
        }
    }
});



=== Transactions et isolation

*  Dans la pratique, les transactions ne
sont en réalité pas toujours bien isolées
*  Il y a quatre niveaux d’isolation,
du plus sécurisé au moins sécurisé :
** SERIALIZABLE
** REPEATABLE READS
** READ COMMITTED
** READ UNCOMMITTED

*  Plus le niveau d’isolation est élevé, plus la base doit locker des
ressources, et moins les performances sont bonnes
*  Le niveau d’isolation par défaut est configurable dans la base de
données, sous Oracle il est à «READ COMMITTED»



=== Les transactions read-only

*  On peut marquer une transaction comme étant «read-only»
**  On indique qu’elle ne va pas modifier de données en base
**  En lecture, il est toujours important d’utiliser des transactions, ne
serait-ce que pour les performances

*  Cet attribut est important
**  Hibernate va le comprendre, il ne va alors plus vérifier s’il doit
impacter des modifications sur les objets en base : meilleures
performances
**  Certains drivers JDBC vont le comprendre (Oracle ne vous autorisera
plus qu’à faire des «SELECT») : meilleure qualité



=== La propagation des transactions 1

*  Que se passe-t-il quand une méthode transactionnelle en
appelle une autre ?

Méthode A => Méthode B => Méthode A



=== La propagation des transactions 2
*  On peut configurer si l’on veut deux transactions différentes ou
une seule transaction englobant les deux méthodes
** REQUIRED : S’il y a déjà une transaction, l’utiliser. Sinon, en créer une
nouvelle. C’est le mode par défaut.
** REQUIRES_NEW : Crée toujours une nouvelle transaction. S’il y en a déjà
une, la suspend.
** NESTED : Peut faire une transaction imbriquée, si cela est supporté par le
gestionnaire de transaction.
** MANDATORY : Une transaction doit déjà exister. Sinon, lance une
Exception.
** SUPPORTS : Si une transaction existe déjà, l’utilise. Sinon, n’utilise pas de
transaction.
** NOT_SUPPORTED : N’utilise pas de transaction. Si une transaction existe
déjà, la suspend.
** NEVER : N’utilise pas de transaction. Si une transaction existe déjà, lance
une Exception.



=== Exemple

*  On peut configurer la transaction via l’annotation
@Transactional : si elle est «read-only», spécifier un timeout
ou un mode de propagation particulier
[source,java]
@Transactional (readOnly = true, timeout = 30,
propagation = Propagation. REQUIRES_NEW )
public void maMethodeMetier() {
//
}



=== Les transactions XA
*  Les transactions XA permettent d’avoir une seule transaction en
utilisant des ressources différentes
** Deux bases de données
** Une base de données et un serveur JMS

*  Pour fonctionner, il faut que ces ressources et le gestionnaire de
transaction supportent les transactions XA
** WebSphere, Weblogic proposent des gestionnaires de transaction XA
** Avec Spring, vous pouvez configurer un gestionnaire de transaction XA
externe : Atomikos, Bitronix

ifdef::backend-revealjs[=== !]

*  Avec Spring, c’est juste une configuration différente de l’
infrastructure
** Aucun changement dans le code !
** Il est déconseillé d’utiliser cette technologie
** On peut généralement obtenir le même résultat de manière plus simple
(sans faire de transaction distribuée)
** De par son fonctionnement, elle est peu performante



=== Pattern «Open Transaction in View»

*  C’est un pattern très répandu dans les applications Web,
aussi appelé «Open Session In View» (la session étant une
session Hibernate)
**  Spring propose un listener de Servlet qui implémente ce pattern

*  Ce pattern est très pratique
**  Permet d’avoir une transaction ouverte tout le temps, y compris dans
les pages Web
**  Règle les problèmes de «lazy loading» avec Hibernate

ifdef::backend-revealjs[=== !]

*  mais parfois des pb de performances
**  Il a tendance à laisser les transactions ouvertes trop longtemps
**  On arrive à terme à une requête HTTP = une transaction, et donc à
une connexion en base de données. Difficile alors de monter en
charge !


=== Conclusion sur les transactions

*  L’utilisation des transactions est essentielle, elle vous
garantie la qualité des données et une bonne performance
*  La configuration des transactions avec Spring est très simple
**  Utilisation des annotations
**  Une configuration avancée reste un simple paramétrage
**  En termes d’architecture, cela permet de gérer les transactions au
niveau de la couche métier (service), et plus dans les couches
basses (repository/DAO)



== Spring MVC

=== Introduction à Spring MVC

*  Spring MVC est un framework Model-View-Controller
** Il permet de faire des applications Web
** Il est relativement simple à apprendre
** Il est performant et robuste
** Il est très configurable

*  Spring MVC est intégré à Spring Core
(ce n’est pas un sous-projet)



=== Les composants de Spring MVC

*  Le Controller
** Un Bean Spring, annoté @Controller
** Supporte donc l’injection de dépendance : c’est ainsi qu’il accède à la
couche Service
** C’est lui qui valide la requête, remplit le modèle, et redirige vers la bonne vue

ifdef::backend-revealjs[=== !]

*  La vue
** C’est typiquement une JSP qui va être chargée d’afficher le modèle
** Spring MVC n’est pas limité à la technologie JSP, mais c’est elle qui est le
plus couramment utilisée

ifdef::backend-revealjs[=== !]

*  Le modèle
** Un Java Bean ou un ensemble de Java Beans (Collection), provenant de la
couche service et étant affiché par la JSP
** Dans l’architecture que nous avons étudiée, ce Java Bean est généralement
une entité Hibernate, ou un ensemble d’entités Hibernate
** Il peut être validé par Bean Validation (cf. chapitre sur Bean Validation)



=== Pré-requis : lancer Spring

*  Avant de configurer et lancer Spring MVC, il faut configurer
et lancer Spring
**  Il s’agit de configurer un listener de Servlet, dans le fichier web.xml
**  Ce listener va lire le fichier de configuration Spring passé en
paramètre, et se charger de lancer le contexte Spring
**  Comme nous l’avons vu dans les chapitres précédents, Spring va
alors trouver la Data Source, lancer JPA, gérer les transactions...

ifdef::backend-revealjs[== !]

Nous aurons donc ainsi une application pleinement fonctionnelle
[source,xml]
<context-param>
<param-name>contextConfigLocation </param-name>
<param-value>classpath:META-INF/spring/application-context.xml </param-value>
</context-param>
<listener>
<listener-class>org.springframework.web.context.ContextLoaderListener </listener-class>
</listener>



=== Configuration de Spring MVC

*  La classe principale est la Servlet nommée DispatcherServlet
**  Elle lance un Application Context Spring
**  Elle lui transmet ensuite les requêtes HTTP
[source,xml]
<servlet>
<servlet-name>dispatcher </servlet-name>
<servlet-class>org.springframework.web.servlet.DispatcherServlet </servlet-class>
<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
<servlet-name>dispatcher </servlet-name>
<url-pattern>/app/*</url-pattern>
</servlet-mapping>



=== Lancement du context Spring MVC

*  Cette Servlet va rechercher un fichier de configuration Spring
**  Par défaut, elle lit le fichier
WEB-INF/${NOM_DE_LA_SERVLET}-servlet.xml
**  Dans notre exemple, il s’agit donc de
WEB-INF/dispatcher-servlet.xml

*  Elle va alors instancier un contexte applicatif Spring, qui sera
un enfant du contexte applicatif principal
**  Voir les Application Contexts hiérarchiques, dans le chapitre sur la
configuration Spring avancée



=== Fichier de configuration de Spring MVC

[source,xml]
<beans xmlns="...">
<context:component-scan base-package="exemple.test.web"/>
<mvc:annotation-driven/>
</beans>



=== Choix de la JSP en fonction de la vue demandée
*  En fonction du nom de la vue demandée, Spring MVC va
retrouver la JSP correspondante
*  Généralement, il s’agit juste de mettre un préfixe et un
suffixe à la vue demandée
**  La vue «account» correspond ainsi à la JSP
«WEB-INF/jsp/account.jsp»
[source,xml]
<bean id="viewResolver"
class="org.springframework.web.servlet.view.UrlBasedViewResolver" >
<property name="viewClass" value="org.springframework.web.servlet.view.JstlView" />
<property name="prefix" value="/WEB-INF/jsp/" />
<property name="suffix" value=".jsp"/>
</bean>



=== Configuration d’un Controller

*  Un Controller Spring MVC est un Bean Spring
**  On peut lui injecter des Beans Spring de la couche service, qui sont
dans l’Application Context Spring parent

*  Il se configure uniquement par annotations
**  Historiquement en XML
**  Généralement, il n’a pas d’interface et on lui laisse son nom par
défaut : il n’est pas destiné à être injecté dans un autre Bean



=== Exemple de Controller
[source,java]
----
@Controller
@RequestMapping ("/account" )
public class AccountController {
    @Inject
    private UserService userService;
    @RequestMapping (method = RequestMethod. GET)
    public ModelAndView display() {
        User user = userService. getCurrentUser ();
        ModelAndView mv = new ModelAndView( "account" );
        mv.addObject ("user", user);
        return mv;
    }
    @RequestMapping (method = RequestMethod. POST)
        public String update( @RequestParam String name) {
        userService. updateName (name);
        return "account_ok" ;
    }
}
----


=== Mapping des requêtes

*  Les requêtes peuvent être mappées au niveau de la classe
ou des méthodes
*  Le mapping s’effectue sur un chemin,
mais peut aussi être fait sur
d’autres critères comme en
fonction du verbe HTTP utilisé
**  GET pour lire une donnée
**  POST pour la mettre à jour



=== Gestion des paramètres passés à la requête

*  La manière la plus simple : ajouter à la méthode un
argument annoté avec @RequestParam

*  Par défaut, ce paramètre est obligatoire et a le même nom
que le nom de la variable
[source,java]
public String update( @RequestParam String name) {...}

*  Cela est bien entendu paramétrable :
[source,java]
public String update(@RequestParam (value="userName" , required= "false") String name) {...}



=== @ModelAttribute sur une méthode (1/2)
*  La première utilisation de @ModelAttribute est de mettre
dans le modèle un objet métier
**  Cet objet peut être une entité JPA
**  Il peut être également un objet spécifiquement développé pour la vue

*  Lorsqu’une méthode est annotée avec @ModelAttribute,
cette méthode est appelée avant chaque mapping
(méthodes annotées @RequestMapping)
**  Ainsi, on est certain d’avoir les bonnes données dès le début
**  Attention : cela peut avoir un impact de performances, surtout si cet
objet n’est pas utilisé dans toutes les méthodes annotées
@RequestMapping



=== @ModelAttribute sur une méthode (2/2)

*  Dans cet exemple, un objet de type User sera stocké
 dans le modèle, avec la clef «user» :
[source,java]
@ModelAttribute("user")
public User formBackingObject() {
   return userService.getCurrentUser();
}



=== @ModelAttribute sur un paramètre de méthode

*  Sur un paramètre d’une méthode annotée
@RequestMapping, l’annotation @ModelAttribute va
permettre de «binder» les paramètres de la requête HTTP
sur cet objet
[source,java]
@RequestMapping(method = RequestMethod.POST)
public String register(@ModelAttribute("user") User user,
BindingResult result) {
    if (result.hasErrors()) {
        return "register";
    }
    return "register_ok";
}



=== L’objet ModelAndView

*  L’objet ModelAndView est retourné par les méthodes du Controller
**  Comme son nom l’indique, il représente le modèle et la vue du
pattern MVC

*  Le modèle est un objet ModelMap, qui est une Map améliorée
**  Les objets mis dans cette Map se retrouvent en attributs dans la
requête HTTP

*  Si le Controller ne retourne qu’une String, il s’agit de la vue à
renvoyer, avec un modèle vide
[source,java]
----
ModelAndView mv = new ModelAndView();
mv.setViewName("account");
mv.addObject("user", user);

ModelAndView mv = new ModelAndView("account");
mv.addObject("user", user);
----


=== La Tag Library de Spring MVC

*  Côté vue, Spring MVC propose une Tag Library pour gérer
les formulaires
**  Cela permet de binder les données du formulaire HTML avec les
méthodes et les paramètres annotés @ModelAttribute

[source,html]
<form:form modelAttribute="user">
<form:input path="firstName" size="15" maxlength="60"/><br/>
<form:input path="lastName" size="15" maxlength="60"/><br/>
<form:select path="sex">
<form:option value="M">M</form:option>
<form:option value="F">F</form:option>
</form:select><br/>
<input type="submit" value="Save Changes" />
</form:form>



=== Spring MVC et Bean Validation (1/2)

* Dans la configuration de Spring MVC, la ligne suivante
permet de prendre en compte Bean Validation :
<mvc:annotation-driven/>

* Ensuite, tout paramètre annoté @Valid sera validé par Bean
Validation avant binding
[source,java]
@RequestMapping(method = RequestMethod.POST)
public String register(@Valid User user, Errors errors) {
    if (errors.hasErrors()) {
        return "register";
    }
    return "register_ok";
}


=== Spring MVC et Bean Validation (2/2)

*  Cette configuration permet d’utiliser Bean Validation, qui est
un standard, pour valider les formulaires HTML
**  Dans ce cadre, on aura certainement des Java Beans spécifiques
pour gérer les formulaires, comme les FormBeans de Struts

ifdef::backend-revealjs[== !]

*  Elle permet également de valider automatiquement les objets
de domaines que l’on afficherait directement dans la page
**  Cela reprend les principes du «DDD» et d’objets de domaine «forts» :
on peut maintenant directement interagir avec ces objets dans la
page HTML
**  Attention, les entités JPA sont ainsi validées deux fois : une fois au
niveau du Controller Spring MVC, et une fois au niveau d’Hibernate



=== Conclusion sur Spring MVC

*  Spring MVC est un framework MVC simple et puissant
**  Il est facile d’accès et très performant
**  Il se configure entièrement grâce à Spring
**  Il utilise son propre Application Context

*  Il est très souple et très paramètrable
**  Cela peut être déroutant, et fait que l’on a parfois des configurations
très complexes

*  Il s’intègre avec Bean Validation pour valider les formulaires




== Spring MVC REST



=== Qu’est-ce que REST ?

*  REST est un style d’architecture distribuée

** De nombreux frameworks facilitent sa mise en oeuvre
** Spring MVC est l’un d’entre eux, son principal intérêt étant justement de ne
pas être limité à ce style d’architecture

*  REST propose de travailler avec des représentations de
ressources, adressables (URL), sur lesquelles il est possible d’agir
à travers l’interface qu’est HTTP (via ses méthodes GET, POST,
PUT, DELETE, …)

ifdef::backend-revealjs[== !]

*  Cette architecture est très bien adaptée au Web
** Elle prône une approche stateless
** Elle tire pleinement partie de HTTP (permet d’utiliser le cache des
navigateurs correctement par exemple)

*  Cette architecture pousse le client à gérer l’état
**  Une page Web avec beaucoup d’Ajax
** Une application mobile



=== Qu’est-ce que les API Web ?

*  Le terme API Web est moins contraignant qu’API REST
** Désigne une API pouvant s’inspirer des principes de REST
** N’oblige pas à honorer l’ensemble des contraintes de REST

ifdef::backend-revealjs[== !]

*  Une API Web pourra donc se conformer plus ou moins au style d’
architeture REST
** On parlera de degré de maturité ou modèle de maturité de Richardson
*** Niveau 3 : Hypermedia As The Engine Of Application State

*** Niveau 2 : Plusieurs URI, plusieurs verbes

*** Niveau 1 : Plusieurs URI, un seul (ou deux) verbes

*** Niveau 0 : Une seule URI, un seul verbe (RPC, SOAP, …)


=== Introduction aux API Web avec Spring MVC

*  Spring MVC permet la réalisation d’API Web via un support
partiel de REST
**  Capacité à créer des représentations de ressources (typiquement les
entités JPA)
**  Capacité à créer des URLs unique vers ces ressources et de les
manipuler avec les verbes HTTP
***  GET /accounts/123 renverra l’objet Account avec la clef 123
***  POST /accounts/123 modifiera l’objet Account avec la clef 123
***  PUT /accounts créera un nouvel objet Account
**  Capacité à utiliser différents media types pour représenter la
ressource en fonction d’un header HTTP ou du suffixe de l’URL
***  «account.json» renverra une représentation au format JSON,
«account.xml» au format XML par exemple


=== Exemple de Controller pour API

*  L’annotation @PathVariable permet de binder un paramètre
de l’URL sur un paramètre de la méthode Java
**  Le nom entre {} dans l’URL est par défaut celui du paramètre Java
[source,java]
----
@Controller
public class TodoListsRest {
    @Inject
    private TodoListsService todoListsService;

    @RequestMapping (value = "/lists/{listId}/todos.json" , method = RequestMethod. GET)
    public Collection<Todo> todos( @PathVariable String listId) {
        TodoList todoList = todoListsService. findTodoList (listId);
        return todoList. getTodos ();
    }
}
----


=== Utilisation des verbes HTTP

*  Une API Web doit tirer profit du protocole HTTP et en utiliser
les verbes pour agir sur les ressources
** GET pour accéder à une ressource
** POST pour mettre à jour une ressource
** PUT pour créer une ressource
** DELETE pour effacer une ressource

ifdef::backend-revealjs[== !]

*  En HTML, nous n’avons accès qu’aux verbes GET et POST
**  Spring MVC simule PUT et DELETE en utilisant le verbe POST avec
un paramètre caché dans les formulaires (grâce au filtre
HiddenHttpMethodFilter)
[source,html]
<form:form method="delete">
    <input type="submit" value="Delete Account"/>
</form:form>



=== Représentation JSON d’une entité

*  JSON est un format très populaire
**  Plus compact que XML, tout en étant aussi lisible
**  Issu de JavaScript, naturellement compris par les navigateurs

*  Spring MVC propose une intégration avec Jackson (http://jackson.codehaus.org/), qui permet de transformer des
objets Java en JSON (et inversement)

ifdef::backend-revealjs[== !]

*  Jackson transformera automatiquement au format JSON les entités
ou collections d’entités retournées par les Controllers
[source,java]
@RequestMapping(value = "/api/lists.json", method = RequestMethod.GET)
@ResponseBody
public Collection<TodoList> lists() {
    User user = userService.getCurrentUser();
    return user.getTodoLists();
}



=== Utilisation du Content-Type

*  Spring MVC peut utiliser le Content-Type (header HTTP) de
la requête pour comprendre qu’un objet envoyé est au format
JSON
**  L’annotation @RequestBody permet de binder le corps de requête
HTTP sur un objet Java
**  Jackson va se charger de transformer le corps de la requête en objet
Java
[source,java]
@RequestMapping(value = "/api/todos",
method = RequestMethod.POST,
consumes="application/json")
public void addTodo(@RequestBody Todo todo, Model model) {
// ajout du Todo
}



=== Configuration de Jackson via Spring

[source,xml]
<bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver" >
<property name="mediaTypes" >
<map>
<entry key="html" value="text/html" />
<entry key="json" value="application/json" />
</map>
</property>
<property name="viewResolvers" >
<list>
<bean class="org.springframework.web.servlet.view.BeanNameViewResolver" />
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver" >
<property name="prefix" value="/WEB-INF/jsp/" />
<property name="suffix" value=".jsp"/>
</bean>
</list>
</property>
<property name="defaultViews" >
<list>
<bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"
</list>
</property>
</bean>
/>

=== Utilisation des ETags

*  Un ETag (Entity Tag) est un header HTTP 1.1
**  Identifiant unique donné par un serveur à une ressource Web
**  Le navigateur peut ainsi mettre en cache la ressource : quand il la
demandera de nouveau, il renverra le ETag, et si elle n’a pas changé
le serveur renverra une réponse HTTP 304 Not Modified
**  Cela permet donc de gagner en trafic réseau

ifdef::backend-revealjs[== !]

*  Spring propose le filtre ShallowEtagHeaderFilter pour
automatiquement gérer les ETags des ressources REST
**  Attention : pour fonctionner, la requête doit quand même
s’exécuter (nous sommes dans un environnement dynamique,
impossible de savoir si la ressource a été modifiée ou pas).
Ce filtre permet donc de gagner du trafic réseau, mais
rien d’autre (l’utilisation du serveur reste identique sinon)


=== Configuration du ShallowEtagHeaderFilter

[source,xml]
<filter>
<filter-name>etagFilter</filter-name>
<filter-class>org.springframework.web.filter.ShallowEtagHeaderFilter</filter-class>
</filter>
<filter-mapping>
<filter-name>etagFilter</filter-name>
<servlet-name>dispatcher</servlet-name>
</filter-mapping>



=== Utilisation avec JQuery

*  Côté client, le moteur JavaScript
comprend le format JSON
*  Avec une librairie comme JQuery, il est très simple de faire
des appels Ajax vers une API Spring MVC
**  Les objets échangés sont au format JSON
**  Les URLs “propres” sont faciles à utiliser avec JQuery
**  L’état est bien géré côté client (nous sommes stateless côté serveur)

ifdef::backend-revealjs[== !]

[source,js]
$.get("/api/accounts/123" , { } ,
function (account) {
$( '#container' ).append( '<div>'+
    account.login + ' - <b>' +
    account.firstName + ' ' +
    account.userLastName +
    '</b></div>' );
}, "json");



=== Conclusion sur Spring MVC pour les API Web

*  Spring MVC permet de simplifier la réalisation d’API Web
**  Support (partiel) de REST : URLs, verbes HTTP, gestion du ContentType, gestion des ETags...
**  Possibilité de conserver Spring MVC pour réaliser des pages Web
plus classiques, en particulier avec un état géré coté serveur

ifdef::backend-revealjs[== !]

*  C’est une excellente manière de réaliser des applications
Web «riches»
**  Le support de JSON permet à du code JavaScript d’interagir
facilement avec une API Spring MVC
**  En particulier, on peut réaliser un client JQuery qui communique via
des requêtes Ajax avec une API codée avec Spring MVC



== Spring Security

=== Introduction à Spring Security

*  Spring Security permet de sécuriser des applications Spring,
en particulier dans un environnement Java EE
*  Il fonctionne dans tous les serveurs d’applications
**  Il vient alors remplacer la sécurité standard Java EE
**  Il est très répandu en production, car il propose des fonctionnalités particulièrement avancées

*  Il se configure via un fichier de configuration Spring
*  Il peut sécuriser des URLs mais aussi des méthodes Java



=== Pourquoi utiliser Spring Security ?

*  Spring Security est une alternative à la sécurité fournie par les
serveurs d’applications Java EE
** Il n’y a pas vraiment d’autre concurrent actuellement (on citera tout de même
Apache Shiro et PicketLink)

* Il se configure via une configuration Spring, et bénéficie de toute la
richesse de celle-ci
** Par exemple, le fait d’avoir facilement plusieurs fichiers d’infrastructure en
fonction de l’environnement est très utile pour un framework de sécurité

*  Il est portable d’un serveur à un autre
*  Il propose une large palette de plugins : utilisation de solutions de
SSO (CAS), de la sécurité Windows (NTLM), de OpenID...
*  Il fournit de nombreux services non disponibles avec Java EE :
gestion des cookies «remember me», sécurité des instances d’
objets, etc...


=== Authentification et Autorisation

*  Il y a deux concepts principaux en sécurité
**  Authentification
***  Vérification de l’identité de la personne
***  En entreprise, on utilise généralement un serveur LDAP
**  Autorisations
***  Les droits sur l’application possédés par la personne
***  Généralement, ces droits sont stockés dans un serveur LDAP ou
une base de données

ifdef::backend-revealjs[== !]

*  Spring Security permet de traiter ces deux concepts de
manière indépendante : par exemple l’authentification en
LDAP et les autorisations en base de données


=== Installation du filtre de Servlet Spring

*  Spring Security est un filtre de Servlet, qui se configure donc
via le fichier web.xml
[source,xml]
<filter>
    <filter-name>springSecurityFilterChain</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
    <filter-name>springSecurityFilterChain</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

*  Il peut ainsi sécuriser toutes les requêtes vers l’application


=== Fonctionnement interne

*  Spring Security va en fait déléguer la gestion des URLs
demandées à une chaîne de filtres spécialisés
**  Ils vont valider si un utilisateur est
authentifié ou non
**  Ils vont valider si un utilisateur a le droit
d’accéder à la ressource ou non
**  Ils vont gérer l’authentification et la
déconnexion de l’utilisateur
**  Ils vont gérer les cas d’erreurs et rediriger
l’utilisateur vers les pages d’erreurs

ifdef::backend-revealjs[== !]

*  La configuration fournie par défaut :
**  fonctionne parfaitement pour un site Web normal
**  est entièrement paramétrable si besoin


=== Configuration minimale

*  Spring Security se configure ensuite dans un fichier de
configuration Spring classique, aidé par un namespace
spécialisé
[source,xml]
<http>
<intercept-url pattern="/app/admin" access="ROLE_ADMIN"/>
<intercept-url pattern="/app/**" access="ROLE_USER"/>
<form-login login-processing-url="/login"
login-page="/welcome"
authentication-failure-url="/welcome?authentication=failure"
default-target-url="/app/index"/>
<logout logout-url="/logout"/>
</http>
<authentication-manager alias="authenticationManager">
<authentication-provider user-service-ref="userDetailsService"/>
</authentication-manager>



=== La règles sur les URLs

*  Les tags <intercept-url/>
associent un ou plusieurs rôles
nécessaires pour accéder à une
URL donnée
*  Ils se configurent avec des
patterns «Ant»

ifdef::backend-revealjs[== !]

*  Ils sont ordonnés : le premier filtre à
intercepter la requête est celui qui va la traiter
*  Il faut donc les ordonner du plus spécialisé au moins spécialisé
** Par exemple : un filtre sur «/**» sera mis à la fin

*  Ils peuvent lister un ou plusieurs rôles de sécurité
** Dans la configuration par défaut, il faut avoir l’un de ces rôles pour avoir
accès à l’URL



=== La page de login

*  Le tag <form-login/> détermine la
page de login
**  Il détermine également l’URL qui va
traiter l’authentification, la page d’erreur,
etc...

ifdef::backend-revealjs[== !]

*  La page de login va alors pointer
vers l’URL de traitement de
l’authentification :
[source,xml]
<form action="${context}/login" method="post">
<label for="login">Login</label>
<input type="text" name="j_username" id="login" />
<label for="password" >Passord</label>
<input type="password" name="j_password" id="password" />
<input type="submit" value="Login" />
</form>



=== Configuration avec un serveur LDAP

*  Cette configuration utilise Spring LDAP, un autre sous-projet
Spring qui facilite l’utilisation d’un serveur LDAP
**  Le namespace Spring Security permet de simplifier cette
configuration
[source,xml]
<ldap-server url="ldap://myldapserver:389/dc=exemple,dc=org" />
<authentication-manager>
<ldap-authentication-provider
user-dn-pattern="uid={0},ou=people"
group-search-base="ou=groups" />
</authentication-manager>



=== Configuration avec une base de données relationnelle

*  Voici la configuration, les requêtes SQL étant paramétrables
[source,xml]
<authentication-manager>
<authentication-provider>
<jdbc-user-service data-source-ref= "dataSource"
users-by-username-query= "..."
authorities-by-username-query= "..."/>
</authentication-provider>
</authentication-manager>

ifdef::backend-revealjs[== !]

*  Les requêtes par défaut sont :

`SELECT username, password, enabled FROM users WHERE username = ?`

`SELECT username, authority FROM authorities WHERE username = ?`



=== Configuration de test

directement dans la configuration Spring

*  Cette configuration est uniquement utile en test, pour pouvoir
facilement ajouter ou modifier des utilisateurs avec des droits
spécifiques
[source,xml]
<authentication-manager>
<authentication-provider>
<user-service>
<user name="admin" password="password1" authorities="ROLE_USER, ROLE_ADMIN" />
<user name="user" password="password1" authorities="ROLE_USER" />
</user-service>
</authentication-provider>
</authentication-manage>



=== Utilisation dans une page Web

*  Spring Security s’intègre avec la sécurité Java EE standard :
les méthodes «isUserInRole» et «getPrincipal» de l’API
Servlet fonctionnent donc
**  Les Tag Lib ou frameworks (Struts) utilisant ces méthodes
fonctionnent sans modification

ifdef::backend-revealjs[== !]

*  Spring Security propose également sa propre Tag Lib, avec
une API plus élaborée :
<sec:authorize access="hasRole('ROLE_ADMIN')">
Seul un administrateur peut voir ce texte !
</sec:authorize>
<sec:authorize url="/admin">
Seule une personne pouvant voir l'URL "/admin" peut voir ce texte !
</sec:authorize>



=== Sécurisation de méthodes Java

*  Spring Security peut également sécuriser l’accès à des
méthodes Java
**  Il s’agit d’un nouvel Aspect (cf. le chapitre
sur Spring AOP pour en voir les limitations)

*  Le PointCut peut s’appliquer sur
**  Une annotation @Secured,
spécifique à Spring Security
**  Une annotation @RolesAllowed,
standardisée dans la JSR 250
<global-method-security secured-annotations= "enabled" />

[source,java]
@Secured ("ROLE_ADMIN" )
public void uneMethodeSecurisee() {
// code ne pouvant être exécuté que par un admin
}


=== Mise en place du «remember me»
*  Spring Security permet de mettre en place un cookie dit
«remember me»
**  C’est une fonctionnalité courante des sites Web, qui permet à un
utilisateur de ne plus renseigner son mot de passe pendant une
période donnée

ifdef::backend-revealjs[== !]

*  Il y a deux implémentations principales
**  Une basée sur un hash, simple à mettre en place, mais qui pose un
problème de sécurité car le mot de passe est alors utilisé dans l’
empreinte MD5 stockée dans le cookie (avec un salt)
**  Une basée sur une table en base de données, que nous
recommandons car elle est plus sécurisée
<http>
...
<remember-me data-source-ref="dataSource"/>
</http>


=== Conclusion sur Spring Security

*  Spring Security est un framework de sécurité robuste et très
répandu en entreprise
**  Il permet de sécuriser des applications Web, en particulier en
donnant des règles d’accès aux URLs
**  Il peut également sécuriser des Beans Spring grâce à un Aspect

ifdef::backend-revealjs[== !]

*  Sa configuration de base est relativement simple, avec l’
utilisation d’un namespace spécifique
*  Il s’intègre avec de nombreuses solutions existantes :
serveur LDAP, base de données, CAS, NTLM, OpenID...

