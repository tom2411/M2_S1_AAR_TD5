= Spring Security
ifndef::masterdoc[]
include::_header.adoc[]
endif::masterdoc[]

Petite introduction à la sécurité avec Spring

== Pré-requis

Avant de sécuriser votre application, il faut avant sécuriser le contexte !

* Utilisation de httpS ; Transport Layer Security (TLS) nom officiel de HTTPS

* Let's Encrypt https://letsencrypt.org/ certificats TLS gratuits

* Normalement, de bout en bout (load balancer, ...)





== Spring Security

=== Introduction à Spring Security

*  Spring Security permet de sécuriser des applications Spring,
en particulier dans un environnement Java EE
*  Il fonctionne dans tous les serveurs d’applications
**  Il vient alors remplacer la sécurité standard Java EE
**  Il est très répandu en production, car il propose des fonctionnalités particulièrement avancées

*  Il se configure via un fichier de configuration Spring
*  Il peut sécuriser des URLs mais aussi des méthodes Java



=== Pourquoi utiliser Spring Security ?

*  Spring Security est une alternative à la sécurité fournie par les
serveurs d’applications Java EE
** Il n’y a pas vraiment d’autre concurrent actuellement (on citera tout de même
Apache Shiro et PicketLink)

* Il se configure via une configuration Spring, et bénéficie de toute la
richesse de celle-ci
** Par exemple, le fait d’avoir facilement plusieurs fichiers d’infrastructure en
fonction de l’environnement est très utile pour un framework de sécurité

*  Il est portable d’un serveur à un autre
*  Il propose une large palette de plugins : utilisation de solutions de
SSO (CAS), de la sécurité Windows (NTLM), de OpenID...
*  Il fournit de nombreux services non disponibles avec Java EE :
gestion des cookies «remember me», sécurité des instances d’
objets, etc...


=== Authentification et Autorisation

*  Il y a deux concepts principaux en sécurité
**  Authentification
***  Vérification de l’identité de la personne
***  En entreprise, on utilise généralement un serveur LDAP
**  Autorisations
***  Les droits sur l’application possédés par la personne
***  Généralement, ces droits sont stockés dans un serveur LDAP ou
une base de données

ifdef::backend-revealjs[== !]

*  Spring Security permet de traiter ces deux concepts de
manière indépendante : par exemple l’authentification en
LDAP et les autorisations en base de données


=== Installation du filtre de Servlet Spring

*  Spring Security est un filtre de Servlet, qui peut se configurer
via le fichier web.xml
[source,xml]
<filter>
    <filter-name>springSecurityFilterChain</filter-name>
    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
    <filter-name>springSecurityFilterChain</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>

*  Il peut ainsi sécuriser toutes les requêtes vers l’application


=== Fonctionnement interne

*  Spring Security va en fait déléguer la gestion des URLs
demandées à une chaîne de filtres spécialisés
**  Ils vont valider si un utilisateur est
authentifié ou non
**  Ils vont valider si un utilisateur a le droit
d’accéder à la ressource ou non
**  Ils vont gérer l’authentification et la
déconnexion de l’utilisateur
**  Ils vont gérer les cas d’erreurs et rediriger
l’utilisateur vers les pages d’erreurs

ifdef::backend-revealjs[== !]

*  La configuration fournie par défaut :
**  fonctionne parfaitement pour un site Web normal
**  est entièrement paramétrable si besoin


=== Configuration minimale

*  Spring Security se configure ensuite dans un fichier de
configuration Spring classique, aidé par un namespace
spécialisé
[source,xml]
<http>
<intercept-url pattern="/app/admin" access="ROLE_ADMIN"/>
<intercept-url pattern="/app/**" access="ROLE_USER"/>
<form-login login-processing-url="/login"
login-page="/welcome"
authentication-failure-url="/welcome?authentication=failure"
default-target-url="/app/index"/>
<logout logout-url="/logout"/>
</http>
<authentication-manager alias="authenticationManager">
<authentication-provider user-service-ref="userDetailsService"/>
</authentication-manager>



=== La règles sur les URLs

*  Les tags <intercept-url/>
associent un ou plusieurs rôles
nécessaires pour accéder à une
URL donnée
*  Ils se configurent avec des
patterns «Ant»

ifdef::backend-revealjs[== !]

*  Ils sont ordonnés : le premier filtre à
intercepter la requête est celui qui va la traiter
*  Il faut donc les ordonner du plus spécialisé au moins spécialisé
** Par exemple : un filtre sur «/**» sera mis à la fin

*  Ils peuvent lister un ou plusieurs rôles de sécurité
** Dans la configuration par défaut, il faut avoir l’un de ces rôles pour avoir
accès à l’URL



=== La page de login

*  Le tag <form-login/> détermine la
page de login
**  Il détermine également l’URL qui va
traiter l’authentification, la page d’erreur,
etc...

ifdef::backend-revealjs[== !]

*  La page de login va alors pointer
vers l’URL de traitement de
l’authentification :
[source,xml]
<form action="${context}/login" method="post">
<label for="login">Login</label>
<input type="text" name="j_username" id="login" />
<label for="password" >Passord</label>
<input type="password" name="j_password" id="password" />
<input type="submit" value="Login" />
</form>



=== Configuration avec un serveur LDAP

*  Cette configuration utilise Spring LDAP, un autre sous-projet
Spring qui facilite l’utilisation d’un serveur LDAP
**  Le namespace Spring Security permet de simplifier cette
configuration
[source,xml]
<ldap-server url="ldap://myldapserver:389/dc=exemple,dc=org" />
<authentication-manager>
<ldap-authentication-provider
user-dn-pattern="uid={0},ou=people"
group-search-base="ou=groups" />
</authentication-manager>



=== Configuration avec une base de données relationnelle

*  Voici la configuration, les requêtes SQL étant paramétrables
[source,xml]
<authentication-manager>
<authentication-provider>
<jdbc-user-service data-source-ref= "dataSource"
users-by-username-query= "..."
authorities-by-username-query= "..."/>
</authentication-provider>
</authentication-manager>

ifdef::backend-revealjs[== !]

*  Les requêtes par défaut sont :

`SELECT username, password, enabled FROM users WHERE username = ?`

`SELECT username, authority FROM authorities WHERE username = ?`



=== Configuration de test

directement dans la configuration Spring

*  Cette configuration est uniquement utile en test, pour pouvoir
facilement ajouter ou modifier des utilisateurs avec des droits
spécifiques
[source,xml]
<authentication-manager>
<authentication-provider>
<user-service>
<user name="admin" password="password1" authorities="ROLE_USER, ROLE_ADMIN" />
<user name="user" password="password1" authorities="ROLE_USER" />
</user-service>
</authentication-provider>
</authentication-manage>



=== Utilisation dans une page Web

*  Spring Security s’intègre avec la sécurité Java EE standard :
les méthodes «isUserInRole» et «getPrincipal» de l’API
Servlet fonctionnent donc
**  Les Tag Lib ou frameworks (Struts) utilisant ces méthodes
fonctionnent sans modification

ifdef::backend-revealjs[== !]

*  Spring Security propose également sa propre Tag Lib, avec
une API plus élaborée :
<sec:authorize access="hasRole('ROLE_ADMIN')">
Seul un administrateur peut voir ce texte !
</sec:authorize>
<sec:authorize url="/admin">
Seule une personne pouvant voir l'URL "/admin" peut voir ce texte !
</sec:authorize>



=== Sécurisation de méthodes Java

*  Spring Security peut également sécuriser l’accès à des
méthodes Java
**  Il s’agit d’un nouvel Aspect (cf. Spring AOP pour en voir les limitations)

*  Le PointCut peut s’appliquer sur
**  Une annotation @Secured,
spécifique à Spring Security
**  Une annotation @RolesAllowed,
standardisée dans la JSR 250

`<global-method-security secured-annotations= "enabled" />`

[source,java]
@Secured ("ROLE_ADMIN" )
public void uneMethodeSecurisee() {
    // code ne pouvant être exécuté que par un admin
}


=== Mise en place du «remember me»

*  Spring Security permet de mettre en place un cookie dit
«remember me»
**  C’est une fonctionnalité courante des sites Web, qui permet à un
utilisateur de ne plus renseigner son mot de passe pendant une
période donnée

ifdef::backend-revealjs[== !]

*  Il y a deux implémentations principales
**  Une basée sur un hash, simple à mettre en place, mais qui pose un
problème de sécurité car le mot de passe est alors utilisé dans l’
empreinte MD5 stockée dans le cookie (avec un salt)
**  Une basée sur une table en base de données recommandée car elle est plus sécurisée

[source,xml]
<http>
...
<remember-me data-source-ref="dataSource"/>
</http>



// ====== PART 2 - with Spring Boot

== Spring security & Spring Boot

=== Activation

Activation par un starter security :
[source,xml]
----
<dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-security</artifactId>
</dependency>
----


=== Conclusion sur Spring Security

*  Spring Security est un framework de sécurité robuste et très
répandu en entreprise
**  Il permet de sécuriser des applications Web, en particulier en
donnant des règles d’accès aux URLs
**  Il peut également sécuriser des Beans Spring grâce à un Aspect

ifdef::backend-revealjs[== !]

*  Sa configuration de base est relativement simple, avec l’
utilisation d’un namespace spécifique
*  Il s’intègre avec de nombreuses solutions existantes :
serveur LDAP, base de données, CAS, NTLM, OpenID...

